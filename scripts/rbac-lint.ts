#!/usr/bin/env tsx
/**
 * RBAC Guard Lint Script
 * 
 * Checks that all API routes have proper RBAC guards:
 * 1. Scans API route files
 * 2. Verifies withRBAC wrapper is present
 * 3. Checks for unprotected routes
 * 
 * Generates: docs/rbac_guard_lint.md
 */

import { readFileSync, writeFileSync, existsSync } from 'fs';
import { join } from 'path';
import { glob } from 'glob';

interface RouteCheck {
  file: string;
  hasGuard: boolean;
  guardPermission?: string;
  issues: string[];
}

/**
 * Check if a route file has RBAC guard
 */
function checkRouteFile(filePath: string): RouteCheck {
  const content = readFileSync(filePath, 'utf-8');
  const check: RouteCheck = {
    file: filePath,
    hasGuard: false,
    issues: [],
  };
  
  // Check for withRBAC wrapper
  const hasWithRBAC = /withRBAC\(['"]([^'"]+)['"]\)/.test(content);
  
  if (hasWithRBAC) {
    check.hasGuard = true;
    const match = content.match(/withRBAC\(['"]([^'"]+)['"]\)/);
    if (match) {
      check.guardPermission = match[1];
    }
  } else {
    // Check if it's a public route (has public keyword or no auth check)
    const isPublicRoute = 
      /export\s+(const\s+)?(GET|POST|PUT|DELETE|PATCH)\s*=\s*(public|unauthenticated)/i.test(content) ||
      /\/\/\s*public/i.test(content) ||
      /\/\/\s*unauthenticated/i.test(content);
    
    if (!isPublicRoute) {
      check.issues.push('Missing RBAC guard - route may be unprotected');
    }
  }
  
  // Check for common security issues
  if (content.includes('createClient') && !content.includes('getServerClient')) {
    check.issues.push('Using client-side Supabase client - should use server client');
  }
  
  return check;
}

/**
 * Generate guard lint report
 */
async function generateGuardLintReport() {
  console.log('ğŸ” Checking RBAC guard compliance...\n');
  
  // Find all API route files
  const routePatterns = [
    'app/**/api/**/route.{ts,tsx}',
    'app/**/api/**/*.{ts,tsx}',
    'src/app/**/api/**/route.{ts,tsx}',
  ];
  
  const routeFiles: string[] = [];
  for (const pattern of routePatterns) {
    try {
      const files = await glob(pattern, { cwd: process.cwd() });
      routeFiles.push(...files);
    } catch (err) {
      // Skip patterns that don't match
    }
  }
  
  console.log(`ğŸ“ Found ${routeFiles.length} route files to check\n`);
  
  // Check each route
  const checks: RouteCheck[] = [];
  for (const file of routeFiles) {
    try {
      const check = checkRouteFile(file);
      checks.push(check);
    } catch (error) {
      checks.push({
        file,
        hasGuard: false,
        issues: [`Error reading file: ${error}`],
      });
    }
  }
  
  // Analyze results
  const guarded = checks.filter(c => c.hasGuard);
  const unguarded = checks.filter(c => !c.hasGuard && c.issues.length > 0);
  const criticalIssues = unguarded.length;
  
  // Generate report
  const timestamp = new Date().toISOString();
  const report = `# ğŸ›¡ï¸ RBAC Guard Lint Report

Generated: ${timestamp}

## ğŸ“Š Executive Summary

- **Total Routes Checked**: ${checks.length}
- **Routes with Guards**: ${guarded.length}
- **Routes without Guards**: ${unguarded.length}
- **Compliance Rate**: ${checks.length > 0 ? Math.round((guarded.length / checks.length) * 100) : 0}%

## ğŸ”´ Critical Issues: ${criticalIssues}

${unguarded.length === 0 
  ? 'âœ… No unprotected routes found' 
  : unguarded.map(c => `### ${c.file}\n\n${c.issues.map(i => `- ${i}`).join('\n')}`).join('\n\n')}

## âœ… Protected Routes

${guarded.length === 0 
  ? 'No protected routes found' 
  : guarded.map(c => `- \`${c.file}\` - \`${c.guardPermission || 'unknown'}\``).join('\n')}

## ğŸ“‹ Recommendations

${criticalIssues > 0 
  ? `### Immediate Action Required\n\n${criticalIssues} route(s) are missing RBAC guards. These routes may be vulnerable to unauthorized access.\n\nAdd \`withRBAC('permission:name')\` wrapper to protect these routes.` 
  : 'âœ… All routes are properly protected with RBAC guards.'}

---
*Report generated by RBAC Guard Lint Script*
`;
  
  // Ensure docs directory exists
  const docsDir = join(process.cwd(), 'docs');
  if (!existsSync(docsDir)) {
    require('fs').mkdirSync(docsDir, { recursive: true });
  }
  
  // Write report
  const reportPath = join(docsDir, 'rbac_guard_lint.md');
  writeFileSync(reportPath, report, 'utf-8');
  console.log(`âœ… Report generated: ${reportPath}\n`);
  
  // Print summary
  console.log(`ğŸ“Š Summary:`);
  console.log(`   - Total routes: ${checks.length}`);
  console.log(`   - Protected: ${guarded.length}`);
  console.log(`   - Unprotected: ${unguarded.length}`);
  console.log(`   - Compliance: ${checks.length > 0 ? Math.round((guarded.length / checks.length) * 100) : 0}%\n`);
  
  if (criticalIssues > 0) {
    console.log(`ğŸš¨ Critical Issues: ${criticalIssues}`);
    unguarded.forEach(c => {
      console.log(`   - ${c.file}`);
      c.issues.forEach(i => console.log(`     ${i}`));
    });
    console.log('');
    process.exit(1);
  } else {
    console.log('âœ… All routes are properly guarded');
    process.exit(0);
  }
}

// Run lint check
generateGuardLintReport().catch(error => {
  console.error('âŒ Fatal error:', error);
  process.exit(1);
});

